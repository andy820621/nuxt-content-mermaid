# Repository Guidelines

## Project Overview
This project enables [Nuxt Content](https://github.com/nuxt/content) to render `mermaid` code blocks in `.md` files by integrating [Mermaid](https://github.com/mermaid-js/mermaid). It provides a Nuxt module that seamlessly handles Mermaid diagram rendering within your Content-driven applications.

## Project Structure & Module Organization
- Core module entry point is located at `src/module.ts`, exporting Nuxt module configuration; runtime code resides in `src/runtime` (components, plugins, server handlers, constants with clear layering), and type definitions in `src/types`.
- Examples and manual verification use `playground` (run `pnpm dev:prepare` first to generate stubs, then `pnpm dev` to start), with build output to `dist`.
- Unit tests are placed in `test`, with the `fixtures` directory storing Markdown examples and expected outputs; keep new test cases aligned with feature directories.

## Build, Test & Development Commands
- `pnpm install`: Install dependencies (recommended to use pnpm, consistent with lockfile).
- `pnpm dev:prepare` / `pnpm dev`: Build module stubs, prepare playground and start local examples.
- `pnpm dev:build`: Build playground only, suitable for verifying production builds.
- `pnpm lint`: Run ESLint to ensure code style aligns with Nuxt conventions.
- `pnpm test` / `pnpm test:watch`: Run Vitest; `pnpm test:types` performs type checking for both root and playground.
- Before release, use `pnpm release:base` (lint + test + build); for versioning use `pnpm release:patch|minor|major` (invokes changelogen).

## Coding Style & Naming Conventions
- TypeScript + ESM, maintain 2-space indentation, avoid using `any`; place public types in `src/types` and export them, runtime constants are centralized in `src/runtime/constants.ts`.
- Vue components use PascalCase (e.g., `Mermaid.vue`), composables and utilities use camelCase; file names should align with exports where possible.
- Runtime logic should be side-effect free when possible, prioritize injection and configuration-driven approaches; synchronize `content.config.ts` and type definitions when adding new configuration options.
- Ensure code passes `pnpm lint` before committing, add brief comments to explain non-obvious logic when necessary.

## Testing Guidelines
- Use Vitest, test files named `*.test.ts`, matching or co-located with the feature being tested; add input and expected Markdown to `test/fixtures` when needed.
- Cover new configurations, theme switching, and lazy-loading paths; for Nuxt runtime logic, reference existing `basic.test.ts` setup patterns.
- Type regression is ensured by `pnpm test:types`; when adding new types or interfaces, update type test cases or playground verification steps.
- Run at least `pnpm lint --fix`, `pnpm test`, and `pnpm test:types` once before merging, recording results in PR description.

## Commit & PR Guidelines
- Commit messages follow Conventional Commits style (e.g., `feat: add spinner option`, `fix: handle dark mode toggle`), facilitating changelogen release notes generation.
- PRs must include: change summary, test results (commands and conclusions), related Issue/discussion links; if UI interaction is involved, attach screenshots or recordings.
- Keep PR size reviewable: separate feature and refactoring commits, avoid mixing formatting and logic changes in the same commit.
- For release-related changes, specify impact scope in description (Nuxt module, runtime, or playground), and confirm `dist` is generated by CI/release pipelineâ€”no need to manually commit build artifacts.
